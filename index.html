<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Heart Fly</title>
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(to bottom right, #ffe4e1, #ffb6c1);
      overflow: hidden;
      font-family: 'Comic Sans MS', cursive;
    }

    canvas {
      display: block;
    }

    .body_left {
      position: absolute;
      left: 0;
      bottom: 0px;
      width: 200px;
      z-index: 10;
    }

    .body_left img {
      width: 100%;
      height: auto;
      object-fit: cover;
    }

    .character {
  position: absolute;
  right: 20px;
  bottom: 0;
  width: 200px;
  z-index: 10;
}

.character img {
  width: 100%;
  height: auto;
}


  </style>
</head>

<body>

    <!-- Nh√¢n v·∫≠t ho·∫°t h√¨nh d·ªÖ th∆∞∆°ng -->
<div class="character">
  <img id="charImg" src="./anhgau01.gif" alt="character" ondragstart="return false;">
</div>


  <!-- Nh√¢n v·∫≠t b·∫Øn tim -->
  <div class="body_left">
    <img src="./biubiubiu.gif" width="150" alt="gif" ondragstart="return false;">
  </div>

  <canvas id="heartCanvas"></canvas>

  <audio id="bgMusic" src=".\amthanhh.mp3" loop></audio>

  <script>
    document.addEventListener("click", () => {
      const music = document.getElementById("bgMusic");
      music.play();
    }, { once: true });
  </script>


  <script>
    const canvas = document.getElementById('heartCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const startX = 150;
    const startY = canvas.height - 150;
    const cellSize = 36;

    const heartBitmap = [
      "0000011100001110000",
      "0001111110011111100",
      "0011111111111111110",
      "0111111111111111111",
      "0111111111111111111",
      "0111111111111111111",
      "0011111111111111110",
      "0001111111111111100",
      "0000111111111111000",
      "0000011111111110000",
      "0000001111111100000",
      "0000000111111000000",
      "0000000011110000000",
      "0000000001100000000"
    ];
 
    const letterBitmaps = {
    "H": [
        "1 1",
        "1 1",
        "111",
        "1 1",
        "1 1"
    ],
    "E": [
        "111",
        "1  ",
        "111",
        "1  ",
        "111"
    ],
    "L": [
        "1  ",
        "1  ",
        "1  ",
        "1  ",
        "111"
    ],
    "O": [
        "111",
        "1 1",
        "1 1",
        "1 1",
        "111"
    ],
    "C": [
        "111",
        "1  ",
        "1  ",
        "1  ",
        "111"
    ],
    "I": [
        "111",
        " 1 ",
        " 1 ",
        " 1 ",
        "111"
    ],
    ":": [
        "   ",
        " 1 ",
        "   ",
        " 1 ",
        "   "
    ],
    ")": [
        " 1 ",
        "  1",
        "  1",
        "  1",
        " 1 "
    ],
    " ": [
        "   ",
        "   ",
        "   ",
        "   ",
        "   "
    ]
};

const text = "HELLO CHI :))";

for (let row = 0; row < 5; row++) {
    let line = "";
    for (let char of text) {
        line += letterBitmaps[char][row] + " ";
    }
    console.log(line);
}

   
for (let row = 0; row < 5; row++) {
    let line = "";
    for (let char of text) {
        line += letterBitmaps[char][row] + " ";
    }
    console.log(line);
}


    const hearts = [];
    const queue = [];
    let allArrived = false;
    let pulseTime = 0;

    const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);

    class FlyingHeart {
      constructor(targetX, targetY, size = 30) {
        this.x = startX;
        this.y = startY;
        this.targetX = targetX;
        this.targetY = targetY;
        this.t = 0;
        this.speed = 0.03 + Math.random() * 0.04;
        this.size = size;
        this.opacity = 0;
        this.arrived = false;
        this.arrivedTime = 0;
      }

      update() {
        if (!this.arrived) {
          this.t += this.speed;
          if (this.t >= 1) {
            this.t = 1;
            this.arrived = true;
          }
          this.x = startX + (this.targetX - startX) * this.t;
          this.y = startY + (this.targetY - startY) * this.t;
          this.opacity = this.t;
        } else {
          this.arrivedTime += 0.05;
        }
      }

      draw(ctx, pulse = 1) {
        ctx.save();
        ctx.globalAlpha = this.opacity;
        let scale = 1;
        if (this.arrived) {
          scale = 1 + 0.1 * Math.sin(this.arrivedTime * 2);
        }
        const s = this.size * scale;
        drawHeartShape(ctx, this.x, this.y - s * 0.5, s);
        ctx.restore();
      }
    }

    // V·∫Ω tr√°i tim
    function drawHeartShape(ctx, x, y, size) {
      ctx.beginPath();
      const topCurveHeight = size * 0.3;
      ctx.moveTo(x, y + topCurveHeight);
      ctx.bezierCurveTo(x, y, x - size / 2, y, x - size / 2, y + topCurveHeight);
      ctx.bezierCurveTo(x - size / 2, y + (size + topCurveHeight) / 2, x, y + (size + topCurveHeight) / 1.2, x, y + size);
      ctx.bezierCurveTo(x, y + (size + topCurveHeight) / 1.2, x + size / 2, y + (size + topCurveHeight) / 2, x + size / 2, y + topCurveHeight);
      ctx.bezierCurveTo(x + size / 2, y, x, y, x, y + topCurveHeight);
      ctx.closePath();

      ctx.shadowColor = "rgba(255, 50, 100, 0.8)";
      ctx.shadowBlur = 20;
      ctx.fillStyle = "#ff4d6d";
      ctx.fill();
    }

    // üëâ tim bay n·ªÅn
    function floatingHeart() {
      const x = Math.random() * canvas.width;
      const y = canvas.height + 30;
      const size = 10 + Math.random() * 20;
      const speed = 1 + Math.random() * 2;
      return { x, y, size, speed };
    }

    let floatingHearts = Array.from({ length: 30 }, floatingHeart);

    function drawFloatingHearts() {
      ctx.save();
      ctx.shadowColor = "rgba(255, 100, 150, 0.5)";
      ctx.shadowBlur = 10;
      ctx.fillStyle = "rgba(255, 150, 180, 0.7)";
      for (let h of floatingHearts) {
        drawHeartShape(ctx, h.x, h.y, h.size);
        h.y -= h.speed;
        if (h.y < -50) Object.assign(h, floatingHeart());
      }
      ctx.restore();
    }

    // V·ªã tr√≠ tr√°i tim l·ªõn
    function getHeartPositions() {
      const totalCols = heartBitmap[0].length;
      const totalRows = heartBitmap.length;
      const offsetX = canvas.width / 2 - (totalCols * cellSize) / 2;
      const offsetY = canvas.height / 2 - (totalRows * cellSize) / 2;

      const positions = [];
      for (let row = 0; row < totalRows; row++) {
        for (let col = 0; col < totalCols; col++) {
          if (heartBitmap[row][col] === '1') {
            const x = offsetX + col * cellSize;
            const y = offsetY + row * cellSize;
            positions.push({ x, y });
          }
        }
      }
      return shuffle(positions);
    }

    // Text ‚ÄúI LOVE YOU‚Äù
    function getTextHeartPositionsSimple(text, baseY) {
      const cell = 10;
      const gap = 18;
      const chars = text.toUpperCase().split('');
      const positions = [];

      const totalWidth = chars.reduce((w, c) => {
        const bmp = letterBitmaps[c] || [];
        return w + (bmp[0]?.length || 0) * cell + gap;
      }, 0);

      const startX = canvas.width / 2 - totalWidth / 2;
      let xOffset = startX;

      for (let char of chars) {
        const bmp = letterBitmaps[char];
        if (!bmp) continue;
        for (let row = 0; row < bmp.length; row++) {
          for (let col = 0; col < bmp[row].length; col++) {
            if (bmp[row][col] === '1') {
              const x = xOffset + col * cell;
              const y = baseY + row * cell;
              positions.push({ x, y });
            }
          }
        }
        xOffset += ((bmp[0]?.length || 0) * cell) + gap + cell / 2;
      }
      return positions;
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    function prepareHeartPixels() {
      const heartPositions = getHeartPositions();
      for (let pos of heartPositions) {
        queue.push(new FlyingHeart(pos.x, pos.y));
      }
      const heartTextY = canvas.height / 2 + 280;
      const textPositions = getTextHeartPositionsSimple("Hello CHI :))", heartTextY);
      for (let pos of textPositions) {
        queue.push(new FlyingHeart(pos.x, pos.y, 10));
      }
    }

    // tim bay th√†nh h√¨nh
    let spawnIndex = 0;
    function spawnLoop() {
      if (spawnIndex < queue.length) {
        hearts.push(queue[spawnIndex++]);
        setTimeout(spawnLoop, 82);
      } else {
        allArrived = true;
      }
    }

    function animate() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawFloatingHearts(); // üëâ v·∫Ω tim n·ªÅn

      const scale = allArrived ? 1.5 + 0.03 * Math.sin(pulseTime) : 1;
      if (allArrived) pulseTime += 0.1;
      

      for (const heart of hearts) {
        heart.update();
        heart.draw(ctx, scale);
      }
      requestAnimationFrame(animate);
    }

    window.onload = () => {
      prepareHeartPixels();
      setTimeout(spawnLoop, 6000);
      animate();
    };
  </script>
</body>
</html>
